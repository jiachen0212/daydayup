一、计算机视觉: 

1. yolo系的优势:
快, pipline轻, 实时性不错, 工业上部署也较成熟.

2. yolox:
	1. 添加EMA权值更新, Cosine学习率机制等训练技巧
	2. 使用IOU loss做reg优化, BCE loss训cls
	3. 添加RandomHorizontalFlip, ColorJitter, 多尺度数据增广, 移除RandomResizedCrop


3. two-stage效果比one-stage好的原因:
	1. 一定程度在RPN节点, 先解决了部分样本不平衡问题(正负的个数, 难度差异)
	2. 有点cascade的意思, RPN筛选了一遍好的proposal, 然后还ROI pooling, 再做cls类别细分和reg. 
	(cls细分相对one-stage也会精度更好些的.)
	3. two的小目标效果会更好(one的input size开太大容易OOM吃不住, 这直接就影响了小目标的精度. 把输入放大是有助于小目标检出的!)


4. 实现focal loss: -alpha*(torch.pow((1-probs), self.gamma))*log_p
ce loss: loss = -log(pt)
focal loss: loss = -alpha*(1-pt)^gamma * log(pt)


5. 针对小目标检测的改进:


6. attention如何计算, self attention除以根号k的原因:
attention计算: kq三个向量做"相关性"计算,再加权到v上.
self attention除以根号k: 主要为了scale, 原因: 
1. 内积值可能很大, 不normalize下的话计算量会较大; 2. 内积值太大送给softmax,可能导致梯度很小. 
[softmax的梯度函数: (a: S(xi)*(1-S(xi) or b: (-S(xi)*S(xj))). 先看a, xi太大了, S(xi)趋近于1, 则a值趋近0; 再看b, 当各xi,j间方差很大, 则xi与xj要么一个0要么一个1, b值仍会趋于0.]. 
So除以sqrt(dk), 把内积方差值化为1,就可解决上面俩"隐患".


7. 用ln（layer norm）的原因:
因为样本长度不一致, 用BN需要把各个句子padding到size一致, 添加太多冗余信息.
另外, 一个句子在内部做统计量抓取就可了, 句子本身就有独立性和分布特性, 无需跨越不用样本(尤其样本间差异很大) 

8. swin transformer: 
1. 在局部小window内做attention, 计算量从图像分辨率的平方倍优化至线性倍; 2. 使用shifted层级结构+patch merging, 实现多层级多感受野目的(第二点也是为分割,检测等密集型预测任务做的必须行优化).

9. transformer编码顺序信息: 
用sin, cosin实现每个句子中词index等价线性, 不受句子长度影响. 4个词的句子和10个词的句子, index=2处的编码力度一致.

10. transformer一般用什么优化器:
建议选择Adamw(搭配大点的learning rate decay), Adam, 毕竟数据需求大且显存要求高. 
理论上: AdamW=Adam+Weight Decay

11. 双摄像头如何实现3d检测:





二、DL base:

1. leaky relu和relu:
relu: 小于0的值直接置0, 会导致部分神经元在训练中被"杀死", 但这个特点也达到: 特征稀疏的作用. 
leaky relu: 负数值scale下: -10 变 -5. 没有绝对的好坏, 这俩激活函数, 根据场景而定.

2. label smooth作用和原理: 
分类来说, 一定程度上缓解过拟合(对于样本间严重不平衡的时候可轻微缓解.)

3. 移动端部署, 网络压缩和加速

4. loss nan 怎么定位和解决
先查数据是否有问题; 再code bug, 网络层写错啥之类的; 再是训练方式: 初始化方式不当, bn没加, 学习率过大, 损失函数用的不当等; 
最后: 可能除以了0, 考虑是网络过程中出现了0值, 定位到对应去改; 

5. 7*7卷积和3个3*3卷积的使用场景有什么不同
7x7大卷积, 可作为大图的特征提取conv, 常在网络的第一层使用. 感受野一下子就上来了. (ConvNeXt, resnet的第一层)
多几个3x3可近似7x7, 计算量更少(中间的激活次数还更多增强非线性)


三、python: 

1. 多线程和多进程: io密集多线程, cpu密集多进程 [python的GIL等待机制导致的]

2. 闭包

3. 装饰器

4. 内存管理 

5. 



C++:

1. const define的区分

2. malloc和new的区别

3. 虚函数

4. 结构体与类的区别

5. 死锁

